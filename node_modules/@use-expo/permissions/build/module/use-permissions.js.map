{"version":3,"sources":["use-permissions.ts"],"names":["useCallback","useEffect","useState","askAsync","getAsync","usePermissions","type","options","data","setData","types","Array","isArray","ask","get","askPermissions","then","getPermissions"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,QAAjC,QAAiD,OAAjD;AACA,SAA6CC,QAA7C,EAAuDC,QAAvD,QAAuE,kBAAvE;AAEA;;;;;;;;;;AASA,OAAO,SAASC,cAAT,CACNC,IADM,EAENC,OAA2B,GAAG,EAFxB,EAOL;AACD,QAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBP,QAAQ,EAAhC;AACA,QAAMQ,KAAK,GAAGC,KAAK,CAACC,OAAN,CAAcN,IAAd,IAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAA3C;AACA,QAAM;AACLO,IAAAA,GAAG,GAAG,KADD;AAELC,IAAAA,GAAG,GAAG;AAFD,MAGFP,OAHJ,CAHC,CAQD;AACA;AACA;;AAEA,QAAMQ,cAAc,GAAGf,WAAW,CAAC,MAClCG,QAAQ,CAAC,GAAGO,KAAJ,CAAR,CAAmBM,IAAnB,CAAwBP,OAAxB,CADiC,EAE/B,CAACH,IAAD,CAF+B,CAAlC,CAZC,CAcW;;AAEZ,QAAMW,cAAc,GAAGjB,WAAW,CAAC,MAClCI,QAAQ,CAAC,GAAGM,KAAJ,CAAR,CAAmBM,IAAnB,CAAwBP,OAAxB,CADiC,EAE/B,CAACH,IAAD,CAF+B,CAAlC,CAhBC,CAkBW;;AAEZL,EAAAA,SAAS,CAAC,MAAM;AACf,QAAIY,GAAJ,EAAS;AACRE,MAAAA,cAAc;AACd;;AAED,QAAI,CAACF,GAAD,IAAQC,GAAZ,EAAiB;AAChBG,MAAAA,cAAc;AACd;AACD,GARQ,EAQN,CAACJ,GAAD,EAAME,cAAN,EAAsBD,GAAtB,EAA2BG,cAA3B,CARM,CAAT;AAUA,SAAO,CAACT,IAAD,EAAOO,cAAP,EAAuBE,cAAvB,CAAP;AACA","sourcesContent":["import { useCallback, useEffect, useState } from 'react';\nimport { PermissionType, PermissionResponse, askAsync, getAsync } from 'expo-permissions';\n\n/**\n * Get or ask permission for protected functionality within the app.\n * It returns the permission response after fetching or asking it.\n * The hook fetches the permissions when rendered, by default.\n * To ask the user permission, use the `askPermission` callback or `ask` option.\n *\n * @see https://docs.expo.io/versions/latest/sdk/permissions/\n * @example const [permission, askPermission, getPermission] = usePermissions(...);\n */\nexport function usePermissions(\n\ttype: PermissionType | PermissionType[],\n\toptions: PermissionsOptions = {},\n): [\n\tPermissionResponse | undefined,\n\t() => Promise<void>,\n\t() => Promise<void>,\n] {\n\tconst [data, setData] = useState<PermissionResponse>();\n\tconst types = Array.isArray(type) ? type : [type];\n\tconst {\n\t\task = false,\n\t\tget = true,\n\t} = options;\n\n\t// note: its intentional to listen to `type`, not `types`.\n\t// when `type` is casted to an array, it possible creates a new one on every render.\n\t// to prevent unnecessary function instances we need to listen to the \"raw\" value.\n\n\tconst askPermissions = useCallback(() => (\n\t\taskAsync(...types).then(setData)\n\t), [type]); // eslint-disable-line react-hooks/exhaustive-deps\n\n\tconst getPermissions = useCallback(() => (\n\t\tgetAsync(...types).then(setData)\n\t), [type]); // eslint-disable-line react-hooks/exhaustive-deps\n\n\tuseEffect(() => {\n\t\tif (ask) {\n\t\t\taskPermissions();\n\t\t}\n\n\t\tif (!ask && get) {\n\t\t\tgetPermissions();\n\t\t}\n\t}, [ask, askPermissions, get, getPermissions]);\n\n\treturn [data, askPermissions, getPermissions];\n}\n\nexport interface PermissionsOptions {\n\t/** If it should ask the permissions when mounted, defaults to `false` */\n\task?: boolean;\n\t/** If it should fetch information about the permissions when mounted, defaults to `true` */\n\tget?: boolean;\n}\n"]}